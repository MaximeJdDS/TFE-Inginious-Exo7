#! /usr/bin/python3
# -*- coding: utf-8 -*-

import subprocess
import gettext
import shlex
import sys
import os
import re

from inginious import feedback
from inginious import rst
from inginious import input
import inginious_container_api.input as ingi_input
import inginious_container_api.feedback as ingi_feedback

def init_translations():
    """
    Move the translations files to student directory
    Initialize gettext and translate to the proper language
    """
    lang = input.get_lang()
    try:
        trad = gettext.GNUTranslations(open("../course/common/student/$i18n/" + lang + ".mo", "rb"))
    except FileNotFoundError:
        trad = gettext.NullTranslations()
    trad.install()

    # Check if the '_' function is properly set up
    global _
    if '_' not in globals() or not callable(_):
        def _(msg):
            return msg  # Fallback to a simple echo function if gettext setup fails
    return lang

def compute_code():
    """
    Fills the template file with the student answer
    Returns the task's number of questions
    """
    for file in os.listdir('./src/Templates'):
        input.parse_template('./src/Templates/' + file, './student/' + file + '.py')
    data = input._load_input()
    return len([k for k in data['input'].keys() if '@' not in k])
        
def cleanup_output(error_content):
    """
        Provides a cleaner output from the error trace

        :param error_content: string returned by the unittest failures
    """
    cleaned_lines = []
    indexes = [match.start() for match in re.finditer('AssertionError: ', error_content)]
    for i in indexes:
        cleaned_lines.append(_('Test échoué:\n'))
        cleaned_lines.append(error_content[i + len("AssertionError: "): error_content.find("=" * 70, i)])
    return ''.join(cleaned_lines) if len(indexes) > 0 else error_content                

def compile_code():
    """
    Compiles both the student code and the exercise code
    Provides feedback if there is any compilation error
    """
    pyc_cmd = "python3 ../course/common/compiler.py "

    with open('log.out', 'w+', encoding="utf-8") as f:
        subprocess.call(shlex.split(pyc_cmd + './student/'), universal_newlines=True, stderr=f)
        f.seek(0)
        out_student = f.read()

    if out_student != "":
        rawhtml = rst.get_codeblock("", out_student)
        feedback.set_global_result('failed')
        feedback.set_global_feedback(_("Ton programme ne compile pas: \n ") + rawhtml + "\n")
        sys.exit(0)

    with open('logTests.out', 'w+', encoding="utf-8") as f:
        subprocess.call(shlex.split(pyc_cmd + './src/'), universal_newlines=True, stderr=f)
        f.seek(0)
        out_tests = f.read()

    if out_tests != "":
        rawhtml = rst.get_codeblock("", out_tests)
        feedback.set_global_result('failed')
        feedback.set_global_feedback(_("Le programme ne compile pas pour des raisons externes,"
                                       "veuillez contacter un administrateur dès que possible: \n ") + rawhtml + "\n")
        sys.exit(0)

    with open('logRunner.out', 'w+', encoding="utf-8") as f:
        subprocess.call(shlex.split(pyc_cmd + '../course/common/'), universal_newlines=True, stderr=f)
        f.seek(0)
        out_runner = f.read()

    if out_runner != "":
        rawhtml = rst.get_codeblock("", out_runner)
        feedback.set_global_result('failed')
        feedback.set_global_feedback(_("Le programme ne compile pas pour des raisons externes,"
                                       "veuillez contacter un administrateur dès que possible: \n ") + rawhtml + "\n")
        sys.exit(0)

def run_code(n_exercises, lang):
    """
    Runs the student code with the tests
    Provides feedback if it contains errors

    :param n_exercises: the task's number of exercises
    :param lang: the language used by the user
    """
    with open('err.txt', 'w+', encoding="utf-8") as f:
        os.chdir('./student')
        py_cmd = "run_student python3 Runner.pyc " + lang
        try:
            resproc = subprocess.Popen(shlex.split(py_cmd), universal_newlines=True, stderr=f, stdout=subprocess.PIPE)
            stdout, _ = resproc.communicate()
            result = resproc.returncode
        except (IOError, BrokenPipeError):
            result = 252
        f.flush()
        f.seek(0)
        errors = f.read()
        outerr = rst.get_codeblock("console", cleanup_output(errors))

    

    # Handle test results as before...
    if result == 127:
        feedback.set_global_result('success')
    elif result == 252:
        feedback.set_global_result('overflow')
    elif result == 253:
        feedback.set_global_result('timeout')
    else:  # Tests failed
        
        if n_exercises == 1:
            feedback.set_global_result('failed')
            feedback.set_global_feedback(("Il semble que votre code contienne des erreurs…\n\n") + outerr + "\n")
        else:
            feedback.set_global_result('failed')
            feedback.set_global_feedback(_("Des erreurs ont été trouvées dans plusieurs questions.\n\n") + outerr + "\n")
               
    # Parse stdout for tags
    tag_lines = [line for line in stdout.split('\n') if line.startswith('TAG:')]
    tags = {line.split(':')[1].split('=')[0]: line.split('=')[1] == 'True' for line in tag_lines}

    # Set tags based on parsed output
    for tag, value in tags.items():
        print(f" tag {tag} = {value}")
        ingi_feedback.set_tag(tag, value)           
               

if __name__ == '__main__':
    language = init_translations()
    num_exercises = compute_code()
    compile_code()
    run_code(num_exercises, language)